
Экзамен на знание основных функций и уменее писать код на языке C
______________________________________________________________________________________________________
Для решения заданий могут использоваться такие функции как:
ft_putnbr
ft_putchar_n
______________________________________________________________________________________________________

LEVEL 1

first_word:
сначала нужно пропустить все пробелы после слова и потом выводить буквы пока не наткнёшься на пробел

fizz_buzz:
нужно использовать оператор % который показывает делится ли число с остатком или нет

ft_strcpy:
нужно пройти вторую строку в цикле и в этом же цикле каждое значение присваивать значению в первой строке

ft_strlen

ft_swap

repeat_alpha:
нужно в цикле напистать условие, что если элемент буква, то мы находим её положение тем, что отнимаем от неё первую букву 'a' которая имеет номер 97. Например бука 'c' это число 99, тогда 99 - 97 = 2 и мы получаем положение буквы если рассматривать алфавит как массив. Но так как в привычном понимании буква с стоит на третьем месте мы выходя из цикла пишем каждую букву ещё раз.

rev_print:
надо просто пройти всю строку первым циклом увеличивая i, а потом вторым массивом выводить каждую букву с помощью i уменьшая её

rot13:
(argv[1][i] - 'a' + 13) % 26 + 'a' : нам нужно положение элемента, поэтому как и в repeat_alpha мы сначала отнимаем 'a', затем прибавляем 13 чтобы сдвинуть элемент. %26 служит для того чтобы в случае когда мы прибавляя 13 к нашему элементу выходим за рамки алфавита он начинался с начала. Например если мы возьмём букву n, то её номер 13 + 13 = 26, 26 % 26 = 0, прибавляем обратно 'a' и получаем 97, алфавит начался сначала.

rotone:
со всеми буквами кроме z увеличиваем сисло на 1, в случае z отнимаем 25, чтобы начать алфавит сначала

search_and_replace

ultstr

------------------------------------------------------------------------------------------------------
LEVEL 2

alpha_mirror:
чтобы поменять букву на противоположную, нужно сначала определить её расстояние относительно z,
122 - argv[1][i] + 97
Например 122 - 97, получаем 25 и теперь переносим это расстояние прибавляя 97

camel_to_snake`:
Если буква большая мы просто делмаем её маленькой и перед тем как выводить её выводим _

do_op:
Просто используем printf и atoi

ft_atoi:
Проходим пробелы, используем переменную sign как -1 если есть - перед числом, пропускаем последующие + и -, res снала 0, поэтому во время обработки первого элемента res = 0 * 10 + str[i] - 0, умножение на 10 нужно для того, чтобы каждая цифра означала десяток, - '0' нужно чтобы конвертировать строку в число

ft_strcmp:
Нужно пройти две строки в цикле и когда они перестанут быть равными друг другу вычесть из элемента первой строки элемент второй

ft_strcspn:
Считает длину сегмента начала строки, состоящего из символов, не присутствующих в reject.
Нужно сравнивать элементы в двух строках и если они совпадут, значит в строке сожержится элемент из reject и мы должны остановить цикл.

ft_strdup:
Аллоцировать память под новую строку использую строку из аргумента функции и в цикле в новую строку внести каждый элемент из старой

ft_strpbrk: 
Делает всё тоже самое что и ft_strcspn, только возвращает указатель на эдлемент, поэтому первую строку нужно проходить в цикле через указатель

ft_strrev:
Сначала проходим всю строку чтобы дойти до последнего элемента, затем используем цикл чтобы одновременно идти с начала строки и с конца меняя элементы местами. Для замены используем переменную temp. str[length - 1 - i]. - 1 используем чтобы не считать '\0' а -i чтобы двигаться с конца строки.

ft_strspn:
Считает длину сегмента начала строки, состоящего из символов, присутствующих в accept, проходим строку и accept, когда наткнёмся на элемент которого нет в accept но есть в строке, возвращаем количество совпадавших элементов

inter:
!inter(argv[1], argv[1][i], i) проверяет чтобы не было повторений, а inter(argv[2], argv[1][i], -1) проверяет чтобы были совпадения. В функции inter цикл while (str[i] && (i < len || len == -1)) проверяет предыдущие элементы на совпадения с текущим.

is_power_of_2:
Нужно чтобы число делилось на два без остатка пока не дойдёт до 1, так как 2 в нулевой степени это одни. Для проверки просто делим число на 2 каждый раз проверяя делится оно без остатка или нет. 
while (n % 2 == 0)
		n /= 2;

union:
Основная идея в том чтобы создать массив на 255 знака (Хоть в Аски и 126 символов лучше использовать 255 для возможности обработать и другие стандарты, хотя мне кажется что код будет работать и со 128 знаками) соотвественно когда мы будем записывать в этот массив символ нам нужно использовать unsigned char который как раз вместо обычного char который хранит от -128 до 127 хранит значения от 0 до 255





