
Экзамен на знание основных функций и уменее писать код на языке C
______________________________________________________________________________________________________
Для решения заданий могут использоваться такие функции как:
ft_putnbr
ft_putchar_n
______________________________________________________________________________________________________

LEVEL 1

first_word:
сначала нужно пропустить все пробелы после слова и потом выводить буквы пока не наткнёшься на пробел

fizz_buzz:
нужно использовать оператор % который показывает делится ли число с остатком или нет

ft_strcpy:
нужно пройти вторую строку в цикле и в этом же цикле каждое значение присваивать значению в первой строке

ft_strlen

ft_swap

repeat_alpha:
нужно в цикле напистать условие, что если элемент буква, то мы находим её положение тем, что отнимаем от неё первую букву 'a' которая имеет номер 97. Например бука 'c' это число 99, тогда 99 - 97 = 2 и мы получаем положение буквы если рассматривать алфавит как массив. Но так как в привычном понимании буква с стоит на третьем месте мы выходя из цикла пишем каждую букву ещё раз.

rev_print:
надо просто пройти всю строку первым циклом увеличивая i, а потом вторым массивом выводить каждую букву с помощью i уменьшая её

rot13:
(argv[1][i] - 'a' + 13) % 26 + 'a' : нам нужно положение элемента, поэтому как и в repeat_alpha мы сначала отнимаем 'a', затем прибавляем 13 чтобы сдвинуть элемент. %26 служит для того чтобы в случае когда мы прибавляя 13 к нашему элементу выходим за рамки алфавита он начинался с начала. Например если мы возьмём букву n, то её номер 13 + 13 = 26, 26 % 26 = 0, прибавляем обратно 'a' и получаем 97, алфавит начался сначала.

rotone:
со всеми буквами кроме z увеличиваем сисло на 1, в случае z отнимаем 25, чтобы начать алфавит сначала

search_and_replace

ultstr

------------------------------------------------------------------------------------------------------
LEVEL 2

alpha_mirror:
чтобы поменять букву на противоположную, нужно сначала определить её расстояние относительно z,
122 - argv[1][i] + 97
например 122 - 97, получаем 25 и теперь переносим это расстояние прибавляя 97

camel_to_snake`:
если буква большая мы просто делмаем её маленькой и перед тем как выводить её выводим _

do_op:
просто используем printf и atoi

ft_atoi:
проходим пробелы, используем переменную sign как -1 если есть - перед числом, пропускаем последующие + и -, res снала 0, поэтому во время обработки первого элемента res = 0 * 10 + str[i] - 0, умножение на 10 нужно для того, чтобы каждая цифра означала десяток, - '0' нужно чтобы конвертировать строку в число

ft_strcmp:
нужно пройти две строки в цикле и когда они перестанут быть равными друг другу вычесть из элемента первой строки элемент второй

ft_strcspn:
нужно сравнивать элементы в двух строках и когда они совпадут вернуть один из них

ft_strdup:
аллоцировать память под новую строку использую строку из аргумента функции и в цикле в новую строку внести каждый элемент из старой

ft_strpbrk: 
делает всё тоже самое что и ft_strcspn, только возвращает указатель на эдлемент, поэтому первую строку нужно проходить в цикле через указатель

ft_strrev:




